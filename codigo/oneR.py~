#!/usr/bin/python
import pandas as pd
import numpy as np
import math
from collections import defaultdict

class OneR:
	"""classe que usa classificador OneR

	It generates one rule for each predictor attribute in the data,
then selects only 1 attribute, whose set of rules gives the smallest total error 

	PS: In this implementation, it assumes there are only non-negative values in the dataset

	"""
	#construtor
	def __init__(self,data_reader,class_values,min_no_bucket,n_discret_bins):
		self.list_rules = []
		self.data = data_reader
		self.class_values = class_values
		#self.attr_error = defaultdict(int)
		self.min_no_bucket = min_no_bucket
		self.n_discret_bins = n_discret_bins	
	
	#generate set of rules in a list
	def produce_rules(self,attr_label,attr_value, class_value, class_label):
		rule = "IF " + attr_label + " = " + attr_value + " THEN " + class_label + " = " +  class_value
		self.list_rules.append(rule)
		
	#return set of rules
	def get_selected_rules(self):
		return self.list_rules

	#return the name of the attribute with the smallest error and its smallest error in a tuple
	def get_attr_small_error(self,l_all_attr,header_line):
		l_total_error = []
		for list_attr_errors in l_all_attr:			
			#calculate the total error for all discrete values	
			total_error = 0				
			for discrete_value, error in list_attr_errors:
				total_error += math.fabs(error)
			l_total_error.append(total_error)
		#get the smallest error
		smallest_error = min(l_total_error)	  
		index_min = np.argmin(l_total_error)
		chosen_attr = header_line[index_min]
		return chosen_attr,smallest_error

	#substitute a certain column's values for its correspondent discret value
	def	substitute_for_discret(self,discret_values,attr_name):
		#header_line = next(self.data)#gets the attribute names
		#for attr_name in header_line:		
		attr_values = self.data[attr_name]#update the position in the column(starts from 1)
		j=0
		for i in range(len(discret_values)):#tests to see in which discret interval does it belong
			interval = discret_values[i]
			#break down its name to get its numeric values
			begin, end = interval.split("to")
			if attr_values[j] >= float(begin) and attr_values[j] < float(end):
				#substitute for its discret value
				attr_values[j] = interval
				j++

	#discretize the numeric values in a predetermined number of intervals(n_discret_bins) AND substitute the numeric values to new discret values
	def discretize_data(self):
		#getting the intervals among all the values of all attributes
		matrix_discret_values = np.array([])
		header_line = next(self.data)#gets the attribute names
		for attr_name in header_line:
			if attr_name == header_line[-1]:
				break
			attr_values = self.data[attr_name]#gets all its values
			max_val = self.data[attr_name].max()
			min_val = self.data[attr_name].min()
			print min_val, maxval
			n = self.n_discret_bins 
			delta = (max_val - min_val)/n
			format(delta, '.6f') #string with 6 decimals precision
			interval_init = min_val
			interval_end = min_val+delta
			format(interval_init, '.6f')#string with 6 decimals precision
			discret_values = np.array([])
			for i in range(n):#save discret values in array
				interval_name = interval_init+"to"+interval_end
				interval_init += delta
				discret_values.append(interval_name)
			self.substitute_for_discret(self,discret_values,attr_name)
			matrix_discret_values.append(discret_values)
		return matrix_discret_values

	#run the algorithm
	def begin_oneR(self):
		m_discret_values = self.discretize_data()
		l_all_attr =[]
		attr_names = []
		header_line = next(self.data)
		class_column = self.data[header_line[-1]]#gets all values related to class column

		#estimate the error related to each attribute
		for attr_name in header_line:
			if attr_name == header_line[-1]:
				break
			attr_values = self.data[attr_name]#gets all its values			
			#attr_names.insert(0,attr_values[0]) #gets the attribute name
			attr_dict =defaultdict(int)
			i=0	#first element value in the class column		
			for discret_value in attr_values:
				#assuming there are ONLY 2 class values
				if class_column[i] == self.class_values[0]:
					attr_dict[discret_value] += 1#+1 for Yes
					i += 1 #next element			
				elif class_column[i]== self.class_values[1]:
					attr_dict[discret_value] -= 1#-1 for No 
					i += 1 #next element
				#order in crescent order by the discret inverval values
				list_attr_errors = sorted(attr_dict.items())
				print list_attr_errors
				l_all_attr.append(list_attr_errors) 
		
		chosen_attr, min_error = self.get_attr_small_error(l_all_attr,header_line)			
		#produce set of rules
		class_label = header_line[-1]
		attr_values = self.data[chosen_attr]#gets all its values
		i=0			
		for discret_value in attr_values:
			class_value = class_column[i]
			self.produce_rules(chosen_attr,discret_value, class_value, class_label)
			i += 1
		print """
-----------------
oneR: finished!
-----------------
		"""
		
